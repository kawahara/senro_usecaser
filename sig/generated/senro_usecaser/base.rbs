# Generated from lib/senro_usecaser/base.rb with RBS::Inline

module SenroUsecaser
  # Represents a step in an organized pipeline
  class Step
    attr_reader use_case_class: untyped

    attr_reader if_condition: untyped

    attr_reader unless_condition: untyped

    attr_reader on_failure: untyped

    attr_reader all_conditions: untyped

    attr_reader any_conditions: untyped

    attr_reader input_mapping: untyped

    # rubocop:disable Metrics/ParameterLists
    # : (singleton(Base), ?if_condition: (Symbol | Proc)?, ?unless_condition: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all_conditions: Array[(Symbol | Proc)]?, ?any_conditions: Array[(Symbol | Proc)]?,
    # :  ?input_mapping: (Symbol | Proc)?) -> void
    def initialize: (untyped use_case_class, ?if_condition: untyped, ?unless_condition: untyped, ?on_failure: untyped, ?all_conditions: untyped, ?any_conditions: untyped, ?input_mapping: untyped) -> untyped

    # Checks if this step should be executed based on conditions
    #
    # : (untyped, untyped) -> bool
    def should_execute?: (untyped, untyped) -> bool

    # Maps the input for this step based on input_mapping configuration
    #
    # : (untyped, untyped) -> untyped
    def map_input: (untyped, untyped) -> untyped

    private

    # : ((Symbol | Proc), untyped, untyped) -> bool
    def evaluate_condition: (Symbol | Proc, untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def all_conditions_met?: (untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def any_condition_met?: (untyped, untyped) -> bool
  end

  # Base class for all UseCases
  #
  # @example Basic UseCase with keyword arguments
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     def call(name:, email:)
  #       user = User.create(name: name, email: email)
  #       success(user)
  #     end
  #   end
  #
  #   result = CreateUserUseCase.call(name: "Taro", email: "taro@example.com")
  #
  # @example With input/output classes (recommended for pipelines)
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     input CreateUserInput
  #     output CreateUserOutput
  #
  #     def call(input)
  #       user = User.create(name: input.name, email: input.email)
  #       success(CreateUserOutput.new(user: user))
  #     end
  #   end
  #
  # @example Pipeline with input/output chaining
  #   class StepA < SenroUsecaser::Base
  #     input AInput
  #     output AOutput
  #     def call(input)
  #       success(AOutput.new(value: input.value * 2))
  #     end
  #   end
  #
  #   class StepB < SenroUsecaser::Base
  #     input AOutput  # Receives StepA's output directly
  #     output BOutput
  #     def call(input)
  #       success(BOutput.new(result: input.value + 1))
  #     end
  #   end
  #
  #   class Pipeline < SenroUsecaser::Base
  #     organize StepA, StepB
  #   end
  class Base
    extend DependsOn

    include DependsOn::InstanceMethods

    # Alias for backward compatibility
    #
    # : () -> (Symbol | String)?
    alias self.use_case_namespace self.declared_namespace

    # Declares a sequence of UseCases to execute as a pipeline
    #
    # @example Basic organize
    #   organize StepA, StepB, StepC
    #
    # @example With block and step
    #   organize do
    #     step StepA
    #     step StepB, if: :should_run?
    #     step StepC, on_failure: :continue
    #   end
    #
    # : (*Class, ?on_failure: Symbol) ?{ () -> void } -> void
    def self.organize: (*Class, ?on_failure: Symbol) ?{ () -> void } -> void

    # Defines a step in the organize block
    #
    # rubocop:disable Metrics/ParameterLists
    # : (Class, ?if: (Symbol | Proc)?, ?unless: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all: Array[(Symbol | Proc)]?, ?any: Array[(Symbol | Proc)]?,
    # :  ?input: (Symbol | Proc)?) -> void
    def self.step: (untyped use_case_class, ?if: untyped, ?unless: untyped, ?on_failure: untyped, ?all: untyped, ?any: untyped, ?input: untyped) -> untyped

    # Returns the list of organized steps
    #
    # : () -> Array[Step]?
    attr_reader organized_steps: untyped

    # Returns the failure handling strategy
    #
    # : () -> Symbol
    def self.on_failure_strategy: () -> Symbol

    # Adds extension modules with hooks
    #
    # : (*Module) -> void
    def self.extend_with: (*Module) -> void

    # Returns the list of extensions
    #
    # : () -> Array[Module]
    def self.extensions: () -> Array[Module]

    # Adds a before hook
    #
    # : () { (untyped) -> void } -> void
    def self.before: () { (untyped) -> void } -> void

    # Returns the list of before hooks
    #
    # : () -> Array[Proc]
    def self.before_hooks: () -> Array[Proc]

    # Adds an after hook
    #
    # : () { (untyped, Result[untyped]) -> void } -> void
    def self.after: () { (untyped, Result[untyped]) -> void } -> void

    # Returns the list of after hooks
    #
    # : () -> Array[Proc]
    def self.after_hooks: () -> Array[Proc]

    # Adds an around hook
    # Block receives (input, use_case, &block) where use_case allows access to dependencies
    #
    # : () { (untyped, Base) { () -> Result[untyped] } -> Result[untyped] } -> void
    def self.around: () ?{ (?) -> untyped } -> untyped

    # Returns the list of around hooks
    #
    # : () -> Array[Proc]
    def self.around_hooks: () -> Array[Proc]

    # Adds an on_failure hook
    #
    # : () { (untyped, Result[untyped], ?RetryContext?) -> void } -> void
    def self.on_failure: () { (untyped, Result[untyped], ?RetryContext?) -> void } -> void

    # Returns the list of on_failure hooks
    #
    # : () -> Array[Proc]
    def self.on_failure_hooks: () -> Array[Proc]

    # Configures automatic retry for specific error types
    #
    # @example Retry on network errors
    #   retry_on :network_error, attempts: 3, wait: 1
    #
    # @example Retry on exception class
    #   retry_on Net::OpenTimeout, attempts: 5, wait: 2, backoff: :exponential
    #
    # @example Multiple error types with jitter
    #   retry_on :rate_limited, :timeout, attempts: 3, wait: 1, jitter: 0.1
    #
    # rubocop:disable Metrics/ParameterLists
    # : (*(Symbol | Class), ?attempts: Integer, ?wait: (Float | Integer),
    # :  ?backoff: Symbol, ?max_wait: (Float | Integer)?, ?jitter: (Float | Integer)) -> void
    def self.retry_on: (*untyped error_matchers, ?attempts: untyped, ?wait: untyped, ?backoff: untyped, ?max_wait: untyped, ?jitter: untyped) -> untyped

    # Returns the list of retry configurations
    #
    # : () -> Array[RetryConfiguration]
    def self.retry_configurations: () -> Array[RetryConfiguration]

    # Configures errors that should immediately discard (no retry)
    #
    # @example Discard on validation errors
    #   discard_on :validation_error, :not_found
    #
    # @example Discard on exception class
    #   discard_on ArgumentError
    #
    # : (*(Symbol | Class)) -> void
    def self.discard_on: (*Symbol | Class) -> void

    # Returns the list of discard matchers
    #
    # : () -> Array[(Symbol | Class)]
    def self.discard_matchers: () -> Array[Symbol | Class]

    # Adds a before_retry hook
    #
    # : () { (untyped, Result[untyped], RetryContext) -> void } -> void
    def self.before_retry: () { (untyped, Result[untyped], RetryContext) -> void } -> void

    # Returns the list of before_retry hooks
    #
    # : () -> Array[Proc]
    def self.before_retry_hooks: () -> Array[Proc]

    # Adds an after_retries_exhausted hook
    #
    # : () { (untyped, Result[untyped], RetryContext) -> void } -> void
    def self.after_retries_exhausted: () { (untyped, Result[untyped], RetryContext) -> void } -> void

    # Returns the list of after_retries_exhausted hooks
    #
    # : () -> Array[Proc]
    def self.after_retries_exhausted_hooks: () -> Array[Proc]

    # Declares the expected input type(s) for this UseCase
    # Accepts a Class or one or more Modules that input must include
    #
    # @example Single class
    #   input UserInput
    #
    # @example Single module (interface)
    #   input HasUserId
    #
    # @example Multiple modules (interfaces)
    #   input HasUserId, HasEmail
    #
    # : (*Module) -> void
    def self.input: (*Module) -> void

    # Returns the input types as an array
    #
    # : () -> Array[Module]
    def self.input_types: () -> Array[Module]

    # Returns the input class (for backwards compatibility)
    # If a Class is specified, returns it. Otherwise returns the first type.
    #
    # : () -> Module?
    def self.input_class: () -> Module?

    # Declares the expected output type for this UseCase
    #
    # : ((Class | Hash[Symbol, Class])) -> void
    def self.output: (Class | Hash[Symbol, Class]) -> void

    # Returns the output schema
    #
    # : () -> (Class | Hash[Symbol, Class])?
    attr_reader output_schema: untyped

    # Calls the UseCase with the given input
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase and captures any exceptions as failures
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call!: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase with custom exception handling options
    #
    # : [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]
    def self.call_with_capture: [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]

    # @api private
    def self.inherited: (untyped subclass) -> untyped

    private def self.copy_configuration_to: (untyped subclass) -> untyped

    private def self.copy_hooks_to: (untyped subclass) -> untyped

    # Initializes the UseCase with dependencies resolved from the container
    #
    # : (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void
    def initialize: (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void

    # Performs the UseCase with hooks
    #
    # : (untyped, ?capture_exceptions: bool) -> Result[untyped]
    def perform: (untyped, ?capture_exceptions: bool) -> Result[untyped]

    # Executes the UseCase logic
    #
    # : (?untyped input) -> Result[untyped]
    def call: (?untyped input) -> Result[untyped]

    # Represents a record of a step execution in a pipeline
    class StepExecutionRecord < Struct[untyped]
      attr_accessor step(): untyped

      attr_accessor input(): untyped

      attr_accessor result(): untyped

      def self.new: (?step: untyped, ?input: untyped, ?result: untyped) -> instance
                  | ({ ?step: untyped, ?input: untyped, ?result: untyped }) -> instance
    end

    private

    # Creates a success Result with the given value
    #
    # : [T] (T) -> Result[T]
    def success: [T] (T) -> Result[T]

    # Creates a failure Result with the given errors
    #
    # : (*Error) -> Result[untyped]
    def failure: (*Error) -> Result[untyped]

    # Creates a failure Result from an exception
    #
    # : (Exception, ?code: Symbol) -> Result[untyped]
    def failure_from_exception: (Exception, ?code: Symbol) -> Result[untyped]

    # Executes a block and captures any exceptions as failures
    #
    # : [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]
    def capture: [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]

    # Validates that input satisfies all declared input types
    # For Modules: checks if input's class includes the module
    # For Classes: checks if input is an instance of the class
    #
    # : (untyped) -> void
    def validate_input!: (untyped) -> void

    # Validates that the result's value satisfies the declared output type
    # Only validates if result is success and output_schema is a Class
    #
    # : (Result[untyped]) -> void
    def validate_output!: (Result[untyped]) -> void

    # Executes the core logic with before/after/around hooks
    #
    # : (untyped) { () -> Result[untyped] } -> Result[untyped]
    def execute_with_hooks: (untyped) { () -> Result[untyped] } -> Result[untyped]

    # Executes the UseCase with retry support
    #
    # : (untyped) -> Result[untyped]
    def execute_with_retry: (untyped) -> Result[untyped]

    # Builds a retry context with max attempts from configurations
    #
    # : () -> RetryContext
    def build_retry_context: () -> RetryContext

    # Finds a retry configuration that matches the result
    #
    # : (Result[untyped]) -> RetryConfiguration?
    def find_matching_retry_config: (Result[untyped]) -> RetryConfiguration?

    # Checks if the result should be discarded (no retry)
    #
    # : (Result[untyped]) -> bool
    def should_discard?: (Result[untyped]) -> bool

    # Runs before_retry hooks
    #
    # : (untyped, Result[untyped], RetryContext) -> void
    def run_before_retry_hooks: (untyped, Result[untyped], RetryContext) -> void

    # Runs after_retries_exhausted hooks
    #
    # : (untyped, Result[untyped], RetryContext) -> void
    def run_after_retries_exhausted_hooks: (untyped, Result[untyped], RetryContext) -> void

    # Wraps a non-Result value in Result.success
    #
    # : (untyped) -> Result[untyped]
    def wrap_result: (untyped) -> Result[untyped]

    # Builds the around hook chain
    #
    # : (untyped, Proc) -> Proc
    def build_around_chain: (untyped, Proc) -> Proc

    # Wraps extension/module around hooks
    #
    # : (untyped, Proc) -> Proc
    def wrap_extension_around_hooks: (untyped, Proc) -> Proc

    # Wraps block-based around hooks (pass self as second argument)
    #
    # : (untyped, Proc) -> Proc
    def wrap_block_around_hooks: (untyped, Proc) -> Proc

    # Collects around hooks from Hook classes and extension modules (not block-based)
    #
    # : () -> Array[Proc]
    def collect_extension_around_hooks: () -> Array[Proc]

    # Runs all before hooks
    #
    # : (untyped) -> void
    def run_before_hooks: (untyped) -> void

    # Runs all after hooks
    #
    # : (untyped, Result[untyped]) -> void
    def run_after_hooks: (untyped, Result[untyped]) -> void

    # Runs all on_failure hooks when result is a failure
    #
    # : (untyped, Result[untyped], ?RetryContext?) -> void
    def run_on_failure_hooks: (untyped, Result[untyped], ?RetryContext?) -> void

    # Calls an on_failure hook with appropriate arguments
    #
    # : (untyped, Symbol, untyped, Result[untyped], RetryContext?) -> void
    def call_on_failure_hook: (untyped, Symbol, untyped, Result[untyped], RetryContext?) -> void

    # Returns instantiated hook objects
    #
    # : () -> Array[Hook]
    def hook_instances: () -> Array[Hook]

    # Checks if the extension is a Hook class
    #
    # : (untyped) -> bool
    def hook_class?: (untyped) -> bool

    # Resolves dependencies from the container
    #
    # : (Container, Hash[Symbol, untyped]) -> void
    def resolve_dependencies: (Container, Hash[Symbol, untyped]) -> void

    # Resolves a single dependency from the container
    # Overrides DependsOn::InstanceMethods to accept container as parameter
    #
    # : (Container, Symbol) -> untyped
    def resolve_from_container: (Container, Symbol) -> untyped

    # Executes the organized UseCase pipeline
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline: (untyped) -> Result[untyped]

    # Executes pipeline with :stop strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_stop: (untyped) -> Result[untyped]

    # Executes pipeline with :continue strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_continue: (untyped) -> Result[untyped]

    # Executes pipeline with :collect strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_collect: (untyped) -> Result[untyped]

    # Updates collect state and checks if pipeline should stop
    #
    # : (Result[untyped], Step, Hash[Symbol, untyped]) -> bool
    def should_stop_collect_pipeline?: (Result[untyped], Step, Hash[Symbol, untyped]) -> bool

    # Builds the final result for collect mode
    #
    # : (Hash[Symbol, untyped]) -> Result[untyped]
    def build_collect_result: (Hash[Symbol, untyped]) -> Result[untyped]

    # Executes a single step in the pipeline
    #
    # : (Step, untyped) -> Result[untyped]
    def execute_step: (Step, untyped) -> Result[untyped]

    # Determines if a step failure should stop the pipeline
    #
    # : (Step) -> bool
    def step_should_stop?: (Step) -> bool

    # Calls a single UseCase in the pipeline
    # Requires input type(s) to be defined for pipeline steps
    # Note: on_failure hooks are not called here - they're called in pipeline rollback
    #
    # : (singleton(Base), untyped) -> Result[untyped]
    def call_use_case: (singleton(Base), untyped) -> Result[untyped]

    # Performs the UseCase as a pipeline step (without on_failure hooks)
    # on_failure hooks are handled by the pipeline's rollback mechanism instead
    #
    # : (untyped, ?capture_exceptions: bool) -> Result[untyped]
    def perform_as_pipeline_step: (untyped, ?capture_exceptions: bool) -> Result[untyped]

    # Executes rollback by calling on_failure hooks on executed steps in reverse order
    # Unlike run_on_failure_hooks, this method calls hooks regardless of result status
    # because we want to rollback even successfully completed steps when pipeline fails
    #
    # : (Array[StepExecutionRecord]) -> void
    def execute_pipeline_rollback: (Array[StepExecutionRecord]) -> void

    # Runs on_failure hooks for rollback purposes (regardless of result status)
    #
    # : (untyped, Result[untyped]) -> void
    def run_rollback_hooks: (untyped, Result[untyped]) -> void
  end
end
