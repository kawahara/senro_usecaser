# Generated from lib/senro_usecaser/base.rb with RBS::Inline

module SenroUsecaser
  # Represents a step in an organized pipeline
  class Step
    attr_reader use_case_class: untyped

    attr_reader if_condition: untyped

    attr_reader unless_condition: untyped

    attr_reader on_failure: untyped

    attr_reader all_conditions: untyped

    attr_reader any_conditions: untyped

    attr_reader input_mapping: untyped

    # rubocop:disable Metrics/ParameterLists
    # : (singleton(Base), ?if_condition: (Symbol | Proc)?, ?unless_condition: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all_conditions: Array[(Symbol | Proc)]?, ?any_conditions: Array[(Symbol | Proc)]?,
    # :  ?input_mapping: (Symbol | Proc | Hash[Symbol, Symbol])?) -> void
    def initialize: (untyped use_case_class, ?if_condition: untyped, ?unless_condition: untyped, ?on_failure: untyped, ?all_conditions: untyped, ?any_conditions: untyped, ?input_mapping: untyped) -> untyped

    # Checks if this step should be executed based on conditions
    #
    # : (untyped, untyped) -> bool
    def should_execute?: (untyped, untyped) -> bool

    # Maps the input for this step based on input_mapping configuration
    #
    # : (untyped, untyped) -> untyped
    def map_input: (untyped, untyped) -> untyped

    private

    # : ((Symbol | Proc), untyped, untyped) -> bool
    def evaluate_condition: (Symbol | Proc, untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def all_conditions_met?: (untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def any_condition_met?: (untyped, untyped) -> bool

    # : (Hash[Symbol, untyped]) -> Hash[Symbol, untyped]
    def map_hash_input: (Hash[Symbol, untyped]) -> Hash[Symbol, untyped]
  end

  # Base class for all UseCases
  #
  # @example Basic UseCase
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     def call(name:, email:)
  #       user = User.create(name: name, email: email)
  #       success(user)
  #     end
  #   end
  #
  #   result = CreateUserUseCase.call(name: "Taro", email: "taro@example.com")
  #
  # @example With dependency injection
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     depends_on :user_repository
  #     depends_on :event_publisher
  #
  #     def call(name:, email:)
  #       user = user_repository.create(name: name, email: email)
  #       event_publisher.publish(UserCreated.new(user))
  #       success(user)
  #     end
  #   end
  #
  # @example With namespace
  #   class Admin::CreateUserUseCase < SenroUsecaser::Base
  #     namespace :admin
  #     depends_on :user_repository  # Resolves from admin namespace
  #
  #     def call(name:, email:)
  #       # ...
  #     end
  #   end
  class Base
    # Declares a dependency to be injected from the container
    #
    # @example Without type (untyped)
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     depends_on :user_repository
    #     depends_on :logger
    #   end
    #
    # @example With type
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     depends_on :user_repository, UserRepository
    #     depends_on :logger, Logger
    #   end
    #
    # : (Symbol, ?Class) -> void
    def self.depends_on: (Symbol, ?Class) -> void

    # Returns the list of declared dependencies
    #
    # : () -> Array[Symbol]
    def self.dependencies: () -> Array[Symbol]

    # Returns the dependency type mapping
    #
    # : () -> Hash[Symbol, Class]
    def self.dependency_types: () -> Hash[Symbol, Class]

    # Sets the namespace for dependency resolution
    #
    # @example
    #   class Admin::CreateUserUseCase < SenroUsecaser::Base
    #     namespace :admin
    #   end
    #
    # @example With nested namespace
    #   class Admin::Reports::GenerateUseCase < SenroUsecaser::Base
    #     namespace "admin::reports"
    #   end
    #
    # : ((Symbol | String)) -> void
    def self.namespace: (Symbol | String) -> void

    # Returns the declared namespace
    #
    # : () -> (Symbol | String)?
    attr_reader use_case_namespace: untyped

    # Declares a sequence of UseCases to execute as a pipeline
    #
    # @example Basic organize (list format)
    #   class CreateOrderUseCase < SenroUsecaser::Base
    #     organize ValidateOrder, ChargePayment, SendConfirmation
    #   end
    #
    # @example With block and step (DSL format)
    #   class CreateOrderUseCase < SenroUsecaser::Base
    #     organize do
    #       step ValidateOrder
    #       step ApplyCoupon, if: :has_coupon?
    #       step ChargePayment, unless: :free_order?
    #       step SendEmail, on_failure: :continue
    #     end
    #   end
    #
    # @example With error strategy
    #   class CreateOrderUseCase < SenroUsecaser::Base
    #     organize ValidateOrder, ChargePayment, on_failure: :collect
    #   end
    #
    # : (*Class, ?on_failure: Symbol) ?{ () -> void } -> void
    def self.organize: (*Class, ?on_failure: Symbol) ?{ () -> void } -> void

    # Defines a step in the organize block
    #
    # @example Basic step
    #   step ValidateOrder
    #
    # @example With conditions
    #   step ApplyCoupon, if: :has_coupon?
    #   step ChargePayment, unless: :free_order?
    #
    # @example With lambda condition
    #   step ApplyCoupon, if: ->(ctx) { ctx[:coupon_code].present? }
    #
    # @example With per-step error handling
    #   step SendEmail, on_failure: :continue
    #
    # @example With multiple conditions (all must be true)
    #   step SendNotification, all: [:has_email?, :notification_enabled?]
    #
    # @example With multiple conditions (any must be true)
    #   step SendEmail, any: [:is_admin?, :is_vip?]
    #
    # @example With custom input mapping (hash)
    #   step CreateUser, input: { name: :user_name, email: :user_email }
    #
    # @example With custom input mapping (method)
    #   step CreateUser, input: :prepare_user_input
    #
    # @example With custom input mapping (lambda)
    #   step CreateUser, input: ->(ctx) { { name: ctx[:full_name] } }
    #
    # rubocop:disable Metrics/ParameterLists
    # : (Class, ?if: (Symbol | Proc)?, ?unless: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all: Array[(Symbol | Proc)]?, ?any: Array[(Symbol | Proc)]?,
    # :  ?input: (Symbol | Proc | Hash[Symbol, Symbol])?) -> void
    def self.step: (untyped use_case_class, ?if: untyped, ?unless: untyped, ?on_failure: untyped, ?all: untyped, ?any: untyped, ?input: untyped) -> untyped

    # Returns the list of organized steps
    #
    # : () -> Array[Step]?
    attr_reader organized_steps: untyped

    # Returns the failure handling strategy
    #
    # : () -> Symbol
    def self.on_failure_strategy: () -> Symbol

    # Adds extension modules with hooks (before/after/around)
    #
    # @example
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     extend_with Logging, Transaction
    #   end
    #
    # : (*Module) -> void
    def self.extend_with: (*Module) -> void

    # Returns the list of extensions
    #
    # : () -> Array[Module]
    def self.extensions: () -> Array[Module]

    # Adds a before hook
    #
    # @example
    #   before { |context| puts "Before: #{context}" }
    #
    # : () { (Hash[Symbol, untyped]) -> void } -> void
    def self.before: () { (Hash[Symbol, untyped]) -> void } -> void

    # Returns the list of before hooks
    #
    # : () -> Array[Proc]
    def self.before_hooks: () -> Array[Proc]

    # Adds an after hook
    #
    # @example
    #   after { |context, result| puts "After: #{result}" }
    #
    # : () { (Hash[Symbol, untyped], Result[untyped]) -> void } -> void
    def self.after: () { (Hash[Symbol, untyped], Result[untyped]) -> void } -> void

    # Returns the list of after hooks
    #
    # : () -> Array[Proc]
    def self.after_hooks: () -> Array[Proc]

    # Adds an around hook
    #
    # @example
    #   around do |context, &block|
    #     ActiveRecord::Base.transaction { block.call }
    #   end
    #
    # : () { (Hash[Symbol, untyped]) { () -> Result[untyped] } -> Result[untyped] } -> void
    def self.around: () ?{ (?) -> untyped } -> untyped

    # Returns the list of around hooks
    #
    # : () -> Array[Proc]
    def self.around_hooks: () -> Array[Proc]

    # Declares the expected input parameters for this UseCase
    #
    # This is primarily for documentation and can be used for validation.
    #
    # @example
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     input CreateUserInput
    #   end
    #
    # : (Class) -> void
    def self.input: (Class) -> void

    # Returns the input class
    #
    # : () -> Class?
    attr_reader input_class: untyped

    # Declares the expected output type for this UseCase
    #
    # This is primarily for documentation and can be used for validation.
    #
    # @example
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     output User
    #   end
    #
    # @example With structure
    #   class CreateUserUseCase < SenroUsecaser::Base
    #     output user: User, token: String
    #   end
    #
    # : ((Class | Hash[Symbol, Class])) -> void
    def self.output: (Class | Hash[Symbol, Class]) -> void

    # Returns the output schema
    #
    # : () -> (Class | Hash[Symbol, Class])?
    attr_reader output_schema: untyped

    # Calls the UseCase with the given input
    #
    # @example With input class
    #   input = CreateUserInput.new(name: "Taro", email: "taro@example.com")
    #   CreateUserUseCase.call(input)
    #
    # @example With custom container
    #   CreateUserUseCase.call(input, container: my_container)
    #
    # @example Pipeline step (keyword arguments)
    #   StepUseCase.call(user_id: 1, product_ids: [101])
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase and captures any exceptions as failures
    #
    # @example
    #   CreateUserUseCase.call!(input)
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call!: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase with custom exception handling options
    #
    # rubocop:disable Layout/LineLength
    # : [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]
    # rubocop:enable Layout/LineLength
    def self.call_with_capture: [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]

    # @api private
    # Hook called when the class is inherited
    def self.inherited: (untyped subclass) -> untyped

    private def self.copy_configuration_to: (untyped subclass) -> untyped

    private def self.copy_hooks_to: (untyped subclass) -> untyped

    # Initializes the UseCase with dependencies resolved from the container
    #
    # @example With global container
    #   use_case = CreateUserUseCase.new
    #
    # @example With custom container
    #   use_case = CreateUserUseCase.new(container: my_container)
    #
    # @example With manual dependencies (for testing)
    #   use_case = CreateUserUseCase.new(dependencies: { user_repository: mock_repo })
    #
    # : (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void
    def initialize: (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void

    # Performs the UseCase with hooks
    #
    # This is the entry point called by class methods.
    # It wraps the call method with before/after/around hooks.
    #
    # : (?untyped, **untyped) -> Result[untyped]
    def perform: (?untyped, **untyped) -> Result[untyped]

    # Executes the UseCase logic
    #
    # If organize is defined, executes the pipeline.
    # Otherwise, subclasses must implement this method.
    #
    # : (?untyped input) -> Result[untyped]
    def call: (?untyped input) -> Result[untyped]

    private

    # Creates a success Result with the given value
    #
    # @example
    #   def call(name:)
    #     user = User.create(name: name)
    #     success(user)
    #   end
    #
    # : [T] (T) -> Result[T]
    def success: [T] (T) -> Result[T]

    # Creates a failure Result with the given errors
    #
    # @example
    #   def call(name:)
    #     return failure(Error.new(code: :invalid, message: "Invalid")) if name.empty?
    #     # ...
    #   end
    #
    # : (*Error) -> Result[untyped]
    def failure: (*Error) -> Result[untyped]

    # Converts an input object to a hash for internal processing
    #
    # : (untyped) -> Hash[Symbol, untyped]
    def input_to_hash: (untyped) -> Hash[Symbol, untyped]

    # Converts a hash to an input object
    #
    # : (Hash[Symbol, untyped]) -> untyped
    def hash_to_input: (Hash[Symbol, untyped]) -> untyped

    # Creates a failure Result from an exception
    #
    # @example
    #   def call(id:)
    #     user = User.find(id)
    #     success(user)
    #   rescue ActiveRecord::RecordNotFound => e
    #     failure_from_exception(e, code: :not_found)
    #   end
    #
    # : (Exception, ?code: Symbol) -> Result[untyped]
    def failure_from_exception: (Exception, ?code: Symbol) -> Result[untyped]

    # Executes a block and captures any exceptions as failures
    #
    # @example
    #   def call(id:)
    #     capture { User.find(id) }
    #   end
    #
    # @example With specific exception classes
    #   def call(id:)
    #     capture(ActiveRecord::RecordNotFound, code: :not_found) { User.find(id) }
    #   end
    #
    # : [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]
    def capture: [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]

    # Executes the core logic with before/after/around hooks
    #
    # : (Hash[Symbol, untyped]) { () -> Result[untyped] } -> Result[untyped]
    def execute_with_hooks: (Hash[Symbol, untyped]) { () -> Result[untyped] } -> Result[untyped]

    # Builds the around hook chain
    #
    # : (Hash[Symbol, untyped], Proc) -> Proc
    def build_around_chain: (Hash[Symbol, untyped], Proc) -> Proc

    # Collects all around hooks from extensions and block-based hooks
    #
    # : () -> Array[Proc]
    def collect_around_hooks: () -> Array[Proc]

    # Runs all before hooks
    #
    # : (Hash[Symbol, untyped]) -> void
    def run_before_hooks: (Hash[Symbol, untyped]) -> void

    # Runs all after hooks
    #
    # : (Hash[Symbol, untyped], Result[untyped]) -> void
    def run_after_hooks: (Hash[Symbol, untyped], Result[untyped]) -> void

    # Resolves dependencies from the container
    #
    # : (Container, Hash[Symbol, untyped]) -> void
    def resolve_dependencies: (Container, Hash[Symbol, untyped]) -> void

    # Resolves a single dependency from the container
    #
    # : (Container, Symbol) -> untyped
    def resolve_from_container: (Container, Symbol) -> untyped

    # Returns the effective namespace for dependency resolution
    # Uses explicitly declared namespace, or infers from module structure if configured
    #
    # : () -> (Symbol | String)?
    def effective_namespace: () -> (Symbol | String)?

    # Infers namespace from the class's module structure
    #
    # @example
    #   Admin::CreateUserUseCase => "admin"
    #   Admin::Reports::GenerateReportUseCase => "admin::reports"
    #   CreateUserUseCase => nil
    #
    # : () -> String?
    def infer_namespace_from_class: () -> String?

    # Executes the organized UseCase pipeline
    # Executes the pipeline with an input object
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_with_input: (untyped) -> Result[untyped]

    #
    # : (**untyped) -> Result[untyped]
    def execute_pipeline: (**untyped) -> Result[untyped]

    # Returns the accumulated context across pipeline steps
    # This is available during pipeline execution.
    #
    # @example Accessing accumulated context
    #   def has_user?(ctx)
    #     accumulated_context[:user].present?
    #   end
    #
    # : () -> Hash[Symbol, untyped]
    def accumulated_context: () -> Hash[Symbol, untyped]

    # Executes pipeline with :stop strategy - stops on first failure
    #
    # : (**untyped) -> Result[untyped]
    def execute_pipeline_stop: (**untyped) -> Result[untyped]

    # Executes pipeline with :continue strategy - continues even on failure
    #
    # : (**untyped) -> Result[untyped]
    def execute_pipeline_continue: (**untyped) -> Result[untyped]

    # Executes pipeline with :collect strategy - collects all errors
    #
    # : (**untyped) -> Result[untyped]
    def execute_pipeline_collect: (**untyped) -> Result[untyped]

    # Processes a single result in collect mode
    #
    # : (Result[untyped], Array[Error], Result[untyped]?, untyped) -> [Array[Error], Result[untyped]?, untyped]
    def process_collect_result: (Result[untyped], Array[Error], Result[untyped]?, untyped) -> [ Array[Error], Result[untyped]?, untyped ]

    # Executes a single step in the pipeline
    #
    # : (Step, untyped) -> Result[untyped]
    def execute_step: (Step, untyped) -> Result[untyped]

    # Determines if a step failure should stop the pipeline
    #
    # : (Step) -> bool
    def step_should_stop?: (Step) -> bool

    # Calls a single UseCase in the pipeline
    #
    # : (singleton(Base), Hash[Symbol, untyped]) -> Result[untyped]
    def call_use_case: (singleton(Base), Hash[Symbol, untyped]) -> Result[untyped]

    # Converts a result to input for the next UseCase
    #
    # : (Result[untyped]) -> Hash[Symbol, untyped]
    def result_to_input: (Result[untyped]) -> Hash[Symbol, untyped]

    # Converts an output object to a hash
    #
    # : (untyped) -> Hash[Symbol, untyped]
    def output_to_hash: (untyped) -> Hash[Symbol, untyped]

    # Checks if the value is a basic Ruby type
    #
    # : (untyped) -> bool
    def basic_type?: (untyped) -> bool

    # Merges new data into the accumulated context
    #
    # : (Hash[Symbol, untyped]) -> void
    def merge_to_accumulated_context: (Hash[Symbol, untyped]) -> void
  end
end
