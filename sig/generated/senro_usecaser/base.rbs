# Generated from lib/senro_usecaser/base.rb with RBS::Inline

module SenroUsecaser
  # Represents a step in an organized pipeline
  class Step
    attr_reader use_case_class: untyped

    attr_reader if_condition: untyped

    attr_reader unless_condition: untyped

    attr_reader on_failure: untyped

    attr_reader all_conditions: untyped

    attr_reader any_conditions: untyped

    attr_reader input_mapping: untyped

    # rubocop:disable Metrics/ParameterLists
    # : (singleton(Base), ?if_condition: (Symbol | Proc)?, ?unless_condition: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all_conditions: Array[(Symbol | Proc)]?, ?any_conditions: Array[(Symbol | Proc)]?,
    # :  ?input_mapping: (Symbol | Proc)?) -> void
    def initialize: (untyped use_case_class, ?if_condition: untyped, ?unless_condition: untyped, ?on_failure: untyped, ?all_conditions: untyped, ?any_conditions: untyped, ?input_mapping: untyped) -> untyped

    # Checks if this step should be executed based on conditions
    #
    # : (untyped, untyped) -> bool
    def should_execute?: (untyped, untyped) -> bool

    # Maps the input for this step based on input_mapping configuration
    #
    # : (untyped, untyped) -> untyped
    def map_input: (untyped, untyped) -> untyped

    private

    # : ((Symbol | Proc), untyped, untyped) -> bool
    def evaluate_condition: (Symbol | Proc, untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def all_conditions_met?: (untyped, untyped) -> bool

    # : (untyped, untyped) -> bool
    def any_condition_met?: (untyped, untyped) -> bool
  end

  # Base class for all UseCases
  #
  # @example Basic UseCase with keyword arguments
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     def call(name:, email:)
  #       user = User.create(name: name, email: email)
  #       success(user)
  #     end
  #   end
  #
  #   result = CreateUserUseCase.call(name: "Taro", email: "taro@example.com")
  #
  # @example With input/output classes (recommended for pipelines)
  #   class CreateUserUseCase < SenroUsecaser::Base
  #     input CreateUserInput
  #     output CreateUserOutput
  #
  #     def call(input)
  #       user = User.create(name: input.name, email: input.email)
  #       success(CreateUserOutput.new(user: user))
  #     end
  #   end
  #
  # @example Pipeline with input/output chaining
  #   class StepA < SenroUsecaser::Base
  #     input AInput
  #     output AOutput
  #     def call(input)
  #       success(AOutput.new(value: input.value * 2))
  #     end
  #   end
  #
  #   class StepB < SenroUsecaser::Base
  #     input AOutput  # Receives StepA's output directly
  #     output BOutput
  #     def call(input)
  #       success(BOutput.new(result: input.value + 1))
  #     end
  #   end
  #
  #   class Pipeline < SenroUsecaser::Base
  #     organize StepA, StepB
  #   end
  class Base
    # Declares a dependency to be injected from the container
    #
    # : (Symbol, ?Class) -> void
    def self.depends_on: (Symbol, ?Class) -> void

    # Returns the list of declared dependencies
    #
    # : () -> Array[Symbol]
    def self.dependencies: () -> Array[Symbol]

    # Returns the dependency type mapping
    #
    # : () -> Hash[Symbol, Class]
    def self.dependency_types: () -> Hash[Symbol, Class]

    # Sets the namespace for dependency resolution
    #
    # : ((Symbol | String)) -> void
    def self.namespace: (Symbol | String) -> void

    # Returns the declared namespace
    #
    # : () -> (Symbol | String)?
    attr_reader use_case_namespace: untyped

    # Declares a sequence of UseCases to execute as a pipeline
    #
    # @example Basic organize
    #   organize StepA, StepB, StepC
    #
    # @example With block and step
    #   organize do
    #     step StepA
    #     step StepB, if: :should_run?
    #     step StepC, on_failure: :continue
    #   end
    #
    # : (*Class, ?on_failure: Symbol) ?{ () -> void } -> void
    def self.organize: (*Class, ?on_failure: Symbol) ?{ () -> void } -> void

    # Defines a step in the organize block
    #
    # rubocop:disable Metrics/ParameterLists
    # : (Class, ?if: (Symbol | Proc)?, ?unless: (Symbol | Proc)?, ?on_failure: Symbol?,
    # :  ?all: Array[(Symbol | Proc)]?, ?any: Array[(Symbol | Proc)]?,
    # :  ?input: (Symbol | Proc)?) -> void
    def self.step: (untyped use_case_class, ?if: untyped, ?unless: untyped, ?on_failure: untyped, ?all: untyped, ?any: untyped, ?input: untyped) -> untyped

    # Returns the list of organized steps
    #
    # : () -> Array[Step]?
    attr_reader organized_steps: untyped

    # Returns the failure handling strategy
    #
    # : () -> Symbol
    def self.on_failure_strategy: () -> Symbol

    # Adds extension modules with hooks
    #
    # : (*Module) -> void
    def self.extend_with: (*Module) -> void

    # Returns the list of extensions
    #
    # : () -> Array[Module]
    def self.extensions: () -> Array[Module]

    # Adds a before hook
    #
    # : () { (untyped) -> void } -> void
    def self.before: () { (untyped) -> void } -> void

    # Returns the list of before hooks
    #
    # : () -> Array[Proc]
    def self.before_hooks: () -> Array[Proc]

    # Adds an after hook
    #
    # : () { (untyped, Result[untyped]) -> void } -> void
    def self.after: () { (untyped, Result[untyped]) -> void } -> void

    # Returns the list of after hooks
    #
    # : () -> Array[Proc]
    def self.after_hooks: () -> Array[Proc]

    # Adds an around hook
    #
    # : () { (untyped) { () -> Result[untyped] } -> Result[untyped] } -> void
    def self.around: () ?{ (?) -> untyped } -> untyped

    # Returns the list of around hooks
    #
    # : () -> Array[Proc]
    def self.around_hooks: () -> Array[Proc]

    # Declares the expected input type for this UseCase
    #
    # : (Class) -> void
    def self.input: (Class) -> void

    # Returns the input class
    #
    # : () -> Class?
    attr_reader input_class: untyped

    # Declares the expected output type for this UseCase
    #
    # : ((Class | Hash[Symbol, Class])) -> void
    def self.output: (Class | Hash[Symbol, Class]) -> void

    # Returns the output schema
    #
    # : () -> (Class | Hash[Symbol, Class])?
    attr_reader output_schema: untyped

    # Calls the UseCase with the given input
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase and captures any exceptions as failures
    #
    # : [T] (?untyped, ?container: Container, **untyped) -> Result[T]
    def self.call!: [T] (?untyped, ?container: Container, **untyped) -> Result[T]

    # Calls the UseCase with custom exception handling options
    #
    # : [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]
    def self.call_with_capture: [T] (input: untyped, ?container: Container, ?exception_classes: Array[Class], ?code: Symbol) -> Result[T]

    # @api private
    def self.inherited: (untyped subclass) -> untyped

    private def self.copy_configuration_to: (untyped subclass) -> untyped

    private def self.copy_hooks_to: (untyped subclass) -> untyped

    # Initializes the UseCase with dependencies resolved from the container
    #
    # : (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void
    def initialize: (?container: Container?, ?dependencies: Hash[Symbol, untyped]) -> void

    # Performs the UseCase with hooks
    #
    # : (untyped, ?capture_exceptions: bool) -> Result[untyped]
    def perform: (untyped, ?capture_exceptions: bool) -> Result[untyped]

    # Executes the UseCase logic
    #
    # : (?untyped input) -> Result[untyped]
    def call: (?untyped input) -> Result[untyped]

    private

    # Creates a success Result with the given value
    #
    # : [T] (T) -> Result[T]
    def success: [T] (T) -> Result[T]

    # Creates a failure Result with the given errors
    #
    # : (*Error) -> Result[untyped]
    def failure: (*Error) -> Result[untyped]

    # Creates a failure Result from an exception
    #
    # : (Exception, ?code: Symbol) -> Result[untyped]
    def failure_from_exception: (Exception, ?code: Symbol) -> Result[untyped]

    # Executes a block and captures any exceptions as failures
    #
    # : [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]
    def capture: [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]

    # Executes the core logic with before/after/around hooks
    #
    # : (untyped) { () -> Result[untyped] } -> Result[untyped]
    def execute_with_hooks: (untyped) { () -> Result[untyped] } -> Result[untyped]

    # Wraps a non-Result value in Result.success
    #
    # : (untyped) -> Result[untyped]
    def wrap_result: (untyped) -> Result[untyped]

    # Builds the around hook chain
    #
    # : (untyped, Proc) -> Proc
    def build_around_chain: (untyped, Proc) -> Proc

    # Collects all around hooks from extensions and block-based hooks
    #
    # : () -> Array[Proc]
    def collect_around_hooks: () -> Array[Proc]

    # Runs all before hooks
    #
    # : (untyped) -> void
    def run_before_hooks: (untyped) -> void

    # Runs all after hooks
    #
    # : (untyped, Result[untyped]) -> void
    def run_after_hooks: (untyped, Result[untyped]) -> void

    # Resolves dependencies from the container
    #
    # : (Container, Hash[Symbol, untyped]) -> void
    def resolve_dependencies: (Container, Hash[Symbol, untyped]) -> void

    # Resolves a single dependency from the container
    #
    # : (Container, Symbol) -> untyped
    def resolve_from_container: (Container, Symbol) -> untyped

    # Returns the effective namespace for dependency resolution
    #
    # : () -> (Symbol | String)?
    def effective_namespace: () -> (Symbol | String)?

    # Infers namespace from the class's module structure
    #
    # : () -> String?
    def infer_namespace_from_class: () -> String?

    # Executes the organized UseCase pipeline
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline: (untyped) -> Result[untyped]

    # Executes pipeline with :stop strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_stop: (untyped) -> Result[untyped]

    # Executes pipeline with :continue strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_continue: (untyped) -> Result[untyped]

    # Executes pipeline with :collect strategy
    #
    # : (untyped) -> Result[untyped]
    def execute_pipeline_collect: (untyped) -> Result[untyped]

    # Updates collect state and checks if pipeline should stop
    #
    # : (Result[untyped], Step, Hash[Symbol, untyped]) -> bool
    def should_stop_collect_pipeline?: (Result[untyped], Step, Hash[Symbol, untyped]) -> bool

    # Builds the final result for collect mode
    #
    # : (Hash[Symbol, untyped]) -> Result[untyped]
    def build_collect_result: (Hash[Symbol, untyped]) -> Result[untyped]

    # Executes a single step in the pipeline
    #
    # : (Step, untyped) -> Result[untyped]
    def execute_step: (Step, untyped) -> Result[untyped]

    # Determines if a step failure should stop the pipeline
    #
    # : (Step) -> bool
    def step_should_stop?: (Step) -> bool

    # Calls a single UseCase in the pipeline
    # Requires input_class to be defined for pipeline steps
    #
    # : (singleton(Base), untyped) -> Result[untyped]
    def call_use_case: (singleton(Base), untyped) -> Result[untyped]
  end
end
