# Generated from lib/senro_usecaser/result.rb with RBS::Inline

module SenroUsecaser
  # Represents the result of a UseCase execution
  #
  # Result is a generic type that holds either a success value or an array of errors.
  # Use {.success} and {.failure} class methods to create instances.
  #
  # @example Success case
  #   result = SenroUsecaser::Result.success(user)
  #   result.success? # => true
  #   result.value    # => user
  #
  # @example Failure case
  #   result = SenroUsecaser::Result.failure(
  #     SenroUsecaser::Error.new(code: :not_found, message: "User not found")
  #   )
  #   result.failure? # => true
  #   result.errors   # => [#<SenroUsecaser::Error ...>]
  #
  # @rbs generic T
  class Result[T]
    attr_reader value: T?

    attr_reader errors: Array[Error]

    # Creates a success Result with the given value
    #
    # : [T] (T) -> Result[T]
    def self.success: [T] (T) -> Result[T]

    # Creates a failure Result with the given errors
    #
    # : (*Error) -> Result[untyped]
    def self.failure: (*Error) -> Result[untyped]

    # Creates a failure Result from an exception
    #
    # @example
    #   begin
    #     # some code that raises
    #   rescue => e
    #     Result.from_exception(e)
    #   end
    #
    # : (Exception, ?code: Symbol) -> Result[untyped]
    def self.from_exception: (Exception, ?code: Symbol) -> Result[untyped]

    # Executes a block and captures any exception as a failure Result
    #
    # @example
    #   result = Result.capture { User.find(id) }
    #   # If User.find raises, result is a failure with the exception
    #   # If User.find succeeds, result is a success with the return value
    #
    # @example With specific exception classes
    #   result = Result.capture(ActiveRecord::RecordNotFound, code: :not_found) do
    #     User.find(id)
    #   end
    #
    # : [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]
    def self.capture: [T] (*Class, ?code: Symbol) { () -> T } -> Result[T]

    # : (?value: T?, ?errors: Array[Error]) -> void
    def initialize: (?value: T?, ?errors: Array[Error]) -> void

    # Returns true if the result is a success
    #
    # : () -> bool
    def success?: () -> bool

    # Returns true if the result is a failure
    #
    # : () -> bool
    def failure?: () -> bool

    # Returns the value if success, otherwise raises an error
    #
    # : () -> T
    def value!: () -> T

    # Returns the value if success, otherwise returns the given default
    #
    # : [U] (U) -> (T | U)
    def value_or: [U] (U) -> (T | U)

    # Applies a block to the value if success, returns failure with same errors if failure
    #
    # : [U] () { (T) -> U } -> Result[U]
    def map: [U] () { (T) -> U } -> Result[U]

    # Applies a block to the value if success, returns failure with same errors if failure
    # The block should return a Result
    #
    # : [U] () { (T) -> Result[U] } -> Result[U]
    def and_then: [U] () { (T) -> Result[U] } -> Result[U]

    # Applies a block to the errors if failure, returns self if success
    #
    # : () { (Array[Error]) -> Result[T] } -> Result[T]
    def or_else: () { (Array[Error]) -> Result[T] } -> Result[T]

    # : (Result[untyped]) -> bool
    def ==: (Result[untyped]) -> bool

    # : () -> String
    def inspect: () -> String
  end
end
