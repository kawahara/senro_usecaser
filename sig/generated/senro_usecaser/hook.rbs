# Generated from lib/senro_usecaser/hook.rb with RBS::Inline

module SenroUsecaser
  # Base class for hooks with dependency injection support
  #
  # Hook classes provide a way to define before/after/around hooks
  # with access to the DI container and automatic dependency resolution.
  #
  # @example Basic hook
  #   class LoggingHook < SenroUsecaser::Hook
  #     depends_on :logger, Logger
  #
  #     def before(input)
  #       logger.info("Starting with #{input.class.name}")
  #     end
  #
  #     def after(input, result)
  #       logger.info("Finished: #{result.success? ? 'success' : 'failure'}")
  #     end
  #   end
  #
  # @example Hook with namespace
  #   class Admin::AuditHook < SenroUsecaser::Hook
  #     namespace :admin
  #     depends_on :audit_logger, AuditLogger
  #
  #     def after(input, result)
  #       audit_logger.log(input: input, result: result)
  #     end
  #   end
  #
  # @example Hook with around
  #   class TransactionHook < SenroUsecaser::Hook
  #     def around(input)
  #       ActiveRecord::Base.transaction { yield }
  #     end
  #   end
  class Hook
    extend DependsOn

    include DependsOn::InstanceMethods

    # Alias for backward compatibility
    #
    # : () -> (Symbol | String)?
    alias self.hook_namespace self.declared_namespace

    # @api private
    def self.inherited: (untyped subclass) -> untyped

    # Initializes the hook with dependencies resolved from the container
    #
    # : (container: Container, ?use_case_namespace: (Symbol | String)?) -> void
    def initialize: (container: Container, ?use_case_namespace: (Symbol | String)?) -> void

    # Called before the UseCase executes
    # Override in subclass to add before logic
    #
    # : (untyped) -> void
    def before: (untyped) -> void

    # Called after the UseCase executes
    # Override in subclass to add after logic
    #
    # : (untyped, Result[untyped]) -> void
    def after: (untyped, Result[untyped]) -> void

    # Wraps the UseCase execution
    # Override in subclass to add around logic
    #
    # : (untyped) { () -> Result[untyped] } -> Result[untyped]
    def around: (untyped) { () -> Result[untyped] } -> Result[untyped]

    # Called when the UseCase fails
    # Override in subclass to add failure handling or rollback logic
    #
    # @example Basic logging
    #   def on_failure(input, result)
    #     logger.error("Failed: #{result.errors.first&.message}")
    #   end
    #
    # @example Request retry
    #   def on_failure(input, result, context)
    #     if result.errors.first&.code == :network_error && context.attempt < 3
    #       context.retry!(wait: 2.0)
    #     end
    #   end
    #
    # : (untyped, Result[untyped], ?RetryContext?) -> void
    def on_failure: (untyped, Result[untyped], ?RetryContext?) -> void

    private

    # Returns the effective namespace for dependency resolution
    # Overrides DependsOn::InstanceMethods to add use_case_namespace fallback
    #
    # : () -> (Symbol | String)?
    def effective_namespace: () -> (Symbol | String)?
  end
end
